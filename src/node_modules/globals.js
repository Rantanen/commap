// 
// Global framework functionality.
//

/*global module, window */
/*jshint nomen:false */
"use strict";

var load = function (load) {
    if (typeof load === 'function') {
        return load();
    } else {
        return load;
    }
};

var noop = function () {};

if (typeof window === 'undefined') {
    global.environment = 'server';
    global.load_on_client = noop;
    global.load_on_server = load;
    global.load_environment = function (envs) {
        return load(envs.server);
    };
} else {
    window.environment = 'client';
    window.load_on_client = load;
    window.load_on_server = noop;
    window.load_environment = function (envs) {
        return load(envs.client);
    };
}

var _classDefs;
load_environment({
    client: function () {
        // Client should have _classDefs supplied by the server.
        _classDefs = window._classDefs;
    },
    server: function () {
        // Server creates a new _classDefs.
        // Reserve index 0 for special handling.
        // (Truthfully we are just lazy and want to use if (this._classDef) :p)
        _classDefs = [ null ];
        global._classDefs = _classDefs;
    }
});

// Define the 'extends' method used in inheritance.
Object.defineProperty(Object.prototype, "extends", { value: function (base) {

    // Maintain the class definition.
    if (!this.prototype) { this.prototype = {}; }
    var clsDef = this.prototype._c;

    // Set the parent prototype without invoking base constructor.
    this.prototype = Object.create(base.prototype);
    if (clsDef) {
        this.prototype._c = clsDef;
    }

    // Create the 'delegateTo' method that can be used to call base functions.
    this.prototype.delegateTo = function (method) {
        var args = [], i;
        for (i = 1; i < arguments.length; i++) { args.push(arguments[i]); }

        return method.apply(this, args);
    };

    // baseReference holds references to the base constructor and methods.
    // Essentially baseReference.foo equals base.prototype.foo
    var baseReference = base;
    for (var i in base.prototype) {
        if (base.prototype.hasOwnProperty(i)) {
            baseReference[i] = base.prototype[i];
        }
    }

    return baseReference;
}});

// Define the 'construct' method used when constructing class instances
// based on data objects.
Object.defineProperty(Object.prototype, "construct", { value: function (type) {

    var obj;

    if (type) {

        obj = Object.create(type.prototype);

    } else if (this._c) {

        var classDef = _classDefs[this._c];

        // Redefine 'require' so browserify ignores it.
        var exprRequire = require;
        var clsDefinition = exprRequire(classDef.path);

        if (classDef.subtype) {
            clsDefinition = clsDefinition[classDef.subtype];
        }

        obj = Object.create(clsDefinition.prototype);

    } else if (this instanceof Array) {
        obj = [];
    } else {
        obj = {};
    }

    for (var i in this) {
        if (this.hasOwnProperty(i)) {

            var item = this[i];

            if (typeof item === 'object') {
                if (item) {
                    obj[i] = this[i].construct();
                } else {
                    obj[i] = item;
                }
            } else {
                obj[i] = item;
            }
        }
    }

    return obj;

}});


// Define the 'construct' method used when constructing class instances
// based on data objects.
Object.defineProperty(Object.prototype, "definedIn", { value: function (file, subtype) {

    var parts = file.split('/');
    var nodeModule_i = parts.length - 1;

    for (; nodeModule_i >= 0 && parts[nodeModule_i] !== 'node_modules'; nodeModule_i--) { }

    var modulePath = parts.slice(nodeModule_i + 1).join('/');

    var classDef;
    load_environment({
        client: function () {
            // On client we should have classDefs supplied by the server.
            for (var i in _classDefs) {
                var cd = _classDefs[i];
                if (cd && cd.path === modulePath && cd.subtype === subtype) {
                    classDef = cd;
                    return;
                }
            }

            // Client didn't find class definition.
            if (!classDef) {
                throw new Error(
                    'Class definition for class ' + modulePath + (subtype ? '#' + subtype : '') +
                    ' not shared with the client. require() in rest/classes.js');
            }
        },
        server: function () {
            // On server we can create classDefs freely.
            classDef = { path: modulePath, subtype: subtype, index: _classDefs.length };
            _classDefs[classDef.index] = classDef;
        }
    });

    this.prototype._c = classDef.index;
    this.prototype.toJSON = function () {
        // Move _c from .prototype to the actual object.
        this._c = this._c;
        return this;
    };

    return this;

}});

