
/*global L, $ */
"use strict";

/*
 *   5      0
 *    ,-''-,
 *   |      | 1
 * 4 |      |
 *    '-,,-'
 *    3    2
 */

var hexSides = {
    0: { adjacent: [ 0, 1 ], pointOffset: [ 0, 1 ] },
    1: { adjacent: [ 1, 0 ], pointOffset: [ Math.sqrt(3/4), 0.5 ] },
    2: { adjacent: [ 1, -1 ], pointOffset: [ Math.sqrt(3/4), -0.5 ] },
    3: { adjacent: [ 0, -1 ], pointOffset: [ 0, -1 ] },
    4: { adjacent: [ -1, 0 ], pointOffset: [ -Math.sqrt(3/4), -0.5 ] },
    5: { adjacent: [ -1, 1 ], pointOffset: [ -Math.sqrt(3/4), 0.5 ] }
};

var zoneIds = {
    'indar': 2,
    'amerish': 6,
    'esamir': 8
};

var factionColors = {
    "1" : 'purple',
    "2" : 'blue',
    "3" : 'red'
};

var HexLayer = L.LayerGroup.extend({
    initialize: function ( continent ) {
        L.Path.CLIP_PADDING = 2;
        var self = this;
        this.continent = continent;

        var dataurl = "http://census.soe.com/s:jubjub/get/ps2-beta/" + continent + "map/?c:limit=100";

        $.ajax( dataurl, { dataType: 'JSONP' } )
            .done( function( data ) { self.addHexes( data ); } );

        L.LayerGroup.prototype.initialize.call( this );
    },

    addHexes: function ( data ) {
        this.hexes = {};
        var collection = data[ this.continent + "map_list" ];
        for( var i in collection ) {
            var area = collection[i];
            var hexList = area.region_hexes_list;
            var h, hex, hexes = {};

            for( h in hexList ) {
                hex = hexList[ h ];
                hexes[ hex.x + "," + hex.y ] = hex;
            }

            // Select the first hex to start drawing from.
            var firstHexIndex = -1;
            var okaySide = null;
            while( okaySide === null ) {
                firstHexIndex++;
                hex = hexList[ firstHexIndex ];
                for( var s = 0; s < 6; s++ ) {
                    var adjacentHex = this.getAdjacentHex(
                        hex, s, hexes );

                    if( !adjacentHex ) {
                        okaySide = s;
                        break;
                    }
                }
            }

            var currentHex = hexList[ firstHexIndex ];
            var currentSide = okaySide;

            var polygon = [];
            var first = this.getHexCorner( currentHex, currentSide );
            var last = null;
            polygon.push( first );

            while( polygon.length < 40 &&
                ( !last || this.pointDistance( first, last ) > 0.0001 ) ) {
                var nextHex = this.getAdjacentHex(
                    currentHex, currentSide, hexes ) || currentHex;

                // Calculate the current side. If we jumped to
                // an adjacent hex, we need to swap the sides a bit too.
                if( nextHex !== currentHex ) {
                    currentSide = ( currentSide + 5 ) % 6;
                } else {
                    currentSide = ( currentSide + 1 ) % 6;
                }

                last = this.getHexCorner( nextHex, currentSide );
                polygon.push( last );
                currentHex = nextHex;
            }

            var polyline = L.polyline( polygon, {
                fill: true,
                stroke: true
            }).addTo( this );

            this.hexes[ area.region_id ] = polyline;
        }

        this.initialized = true;
        this.updateHexStatus();
    },

    onAdd: function ( map ) {
        var self = this;

        L.LayerGroup.prototype.onAdd.call( this, map );

        this.active = true;
        this.updateHexStatus();
        this.updateInterval = setInterval( function () { self.updateHexStatus(); }, 60000 );
    },

    onRemove: function ( map ) {
        clearInterval( this.updateInterval );
        this.updateInterval = false;
        this.active = false;

        L.LayerGroup.prototype.onRemove.call( this, map );
    },

    updateHexStatus: function () {
        if( !this.initialized || !this.active ) { return; }
        var self = this;

        var dataurl = "http://census.soe.com/s:jubjub/get/ps2-beta/map/?world_id=13&zone_ids=" + zoneIds[ this.continent ];
        $.ajax( dataurl, { dataType: 'JSONP' }).done( function ( data ) {
            var areaList = data.map_list[0].Regions.Row;
            for( var i in areaList ) {
                var area = areaList[i].RowData;
                var hex = self.hexes[ area.RegionId ];
                if( !hex ) {
                    continue;
                }

                if( hex.faction !== area.FactionId ) {
                    var color = factionColors [ area.FactionId ];
                    hex.setStyle({ fillColor: color, color: color });
                    hex.faction = area.FactionId;
                }
            }
        });
    },

    getAdjacentHex: function( hex, side, hexes ) {
        var sideInfo = hexSides[side];
        var adjacentCoords = [
            1*hex.x + sideInfo.adjacent[0],
            1*hex.y + sideInfo.adjacent[1]
        ];
        var adjacentHex = hexes[
            adjacentCoords[0] + "," +
            adjacentCoords[1] ];

        return adjacentHex;
    },

    pointDistance: function( p1, p2 ) {
        return Math.pow(p1[0] - p2[0], 2) +
               Math.pow(p1[1] - p2[1], 2);
    },

    getHexCorner: function( hex, corner ) {
        hex = this.hexCoords( hex );
        var side = hexSides[ corner ];
        return this.hexToMapCoords([
            hex[0] + side.pointOffset[0],
            hex[1] + side.pointOffset[1]
        ]);
    },

    hexCoords: function ( hex ) {
        // str -> int conversion.
        hex = { x: 1*hex.x, y: 1*hex.y };
        var y_dist = 1.5;
        var x_dist = Math.sqrt(3);
        return [
            hex.x * x_dist + (hex.y * x_dist/2),
            hex.y * y_dist + 1
        ];
    },

    hexToMapCoords: function ( hex ) {

        var hex_scale = 0.02361;
        var offset = [ 0.5, 0.5 ];
        var c = [
            hex[0] * hex_scale + offset[0],
            hex[1] * hex_scale + offset[1]
        ];
        return c;
    }
});

module.exports = HexLayer;
